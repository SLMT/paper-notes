<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SIGMOD&#x27;21 - Scalable Multi-Query Execution using Reinforcement Learning - Paper Notes</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../cover.html">Cover</a></li><li class="chapter-item expanded affix "><a href="../template.html">Template</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../dbms_machine_provisioning/summary.html"><strong aria-hidden="true">1.</strong> DBMS Workload Modeling &amp; Machine Provisioning</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dbms_machine_provisioning/sheikh2011bayesian.html"><strong aria-hidden="true">1.1.</strong> ICAC'11 - Modeling Workloads using Gaussian Process</a></li><li class="chapter-item expanded "><a href="../dbms_machine_provisioning/taft2018pstore.html"><strong aria-hidden="true">1.2.</strong> SIGMOD'18 - P-Store</a></li></ol></li><li class="chapter-item expanded "><a href="../dbms_data_partitioning/summary.html"><strong aria-hidden="true">2.</strong> DBMS Data Partitioning</a></li><li class="chapter-item expanded "><a href="../dbms_query_processing/summary.html"><strong aria-hidden="true">3.</strong> DBMS Query Processing</a></li><li class="chapter-item expanded "><a href="../dbms_scalability/summary.html"><strong aria-hidden="true">4.</strong> DBMS Scalability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dbms_scalability/lu2019star.html"><strong aria-hidden="true">4.1.</strong> VLDB'19 - Star</a></li><li class="chapter-item expanded "><a href="../dbms_scalability/georgiou2020hihooi.html"><strong aria-hidden="true">4.2.</strong> TKDE'20 - Hihooi</a></li></ol></li><li class="chapter-item expanded "><a href="../deterministic_dbms/summary.html"><strong aria-hidden="true">5.</strong> Deterministic DBMS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../deterministic_dbms/ren2014evaluation.html"><strong aria-hidden="true">5.1.</strong> VLDB'14 - Advantages and Disadvantages of Deterministic DBMS</a></li><li class="chapter-item expanded "><a href="../deterministic_dbms/lu2020aria.html"><strong aria-hidden="true">5.2.</strong> VLDB'20 - Aria</a></li></ol></li><li class="chapter-item expanded "><a href="../dbms_with_ai/summary.html"><strong aria-hidden="true">6.</strong> DBMS + AI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dbms_with_ai/aken2017ottertune.html"><strong aria-hidden="true">6.1.</strong> SIGMOD'17 - OtterTune</a></li><li class="chapter-item expanded "><a href="../dbms_with_ai/marcus2019dlquery.html"><strong aria-hidden="true">6.2.</strong> CIDR'19 - Query Optimizer through DL</a></li><li class="chapter-item expanded "><a href="../dbms_with_ai/zhou2020dbaisurvey.html"><strong aria-hidden="true">6.3.</strong> TKDE'20 - Database Meets AI: A Survey</a></li><li class="chapter-item expanded "><a href="../dbms_with_ai/lin2021mb2.html"><strong aria-hidden="true">6.4.</strong> SIGMOD'21 - MB2</a></li><li class="chapter-item expanded "><a href="../dbms_with_ai/hilprecht2022zeroshot.html"><strong aria-hidden="true">6.5.</strong> CIDR'22 - Zero-Shot Learning on DBMS</a></li><li class="chapter-item expanded "><a href="../dbms_with_ai/sioulas2021roulette.html" class="active"><strong aria-hidden="true">6.6.</strong> SIGMOD'21 - Scalable Multi-Query Execution using Reinforcement Learning</a></li></ol></li><li class="chapter-item expanded "><a href="../rl_to_rank/summary.html"><strong aria-hidden="true">7.</strong> Reinforcement Learning to Rank</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rl_to_rank/zhou2020rlirank.html"><strong aria-hidden="true">7.1.</strong> WWW'20 - RLIRank</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Paper Notes</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scalable-multi-query-execution-using-reinforcement-learning"><a class="header" href="#scalable-multi-query-execution-using-reinforcement-learning">Scalable Multi-Query Execution using Reinforcement Learning</a></h1>
<ul>
<li>Authors: Panagiotis Sioulas, Anastasia Ailamaki</li>
<li>Institute: EPFL</li>
<li>Published at SIGMOD'21</li>
<li>Paper Link: <a href="https://dl.acm.org/doi/10.1145/3448016.3452799">https://dl.acm.org/doi/10.1145/3448016.3452799</a></li>
</ul>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<h3 id="vectorized-execution"><a class="header" href="#vectorized-execution">Vectorized Execution</a></h3>
<p>Vectorized execution 是一種藉由 SIMD 來加速 query execution 的作法。 SIMD 的特色在於可以藉由一道 instruction 同時對多個資料進行相同操作，可以大幅增加平行性。 Vectorized execution 則是為了要使用 SIMD 進行 query execution，必須設計特別的 algorithm 把要處理的資料轉成 vector，然後對這些 vector 進行 SIMD 操作來完成 query execution。</p>
<p>常見可以做 vectorized execution 的動作包括：</p>
<ul>
<li>Scan with filtering</li>
<li>Hash Table Probing</li>
<li>Histogram Building</li>
</ul>
<p>Reference: Andy Pavlo 的 <a href="https://15721.courses.cs.cmu.edu/spring2020/schedule.html">Vectorized Execution 課程</a>。</p>
<h3 id="work-sharing"><a class="header" href="#work-sharing">Work-Sharing</a></h3>
<ul>
<li>Global Query Plan: a shared plan for multiple queries</li>
<li>Online sharing: 線上一邊接受新 query，一邊將 query plan 與執行中的 query 合併來減少資源花費。
<ul>
<li>關鍵問題在於：已經在執行的 query plan 是無法更改的。因此新進來的 query plan 只能配合執行中的 query plan 偵測相似的 sub-plan。然而實際上考慮所有 query 的可能 query plan 的時候，是有可能找到更好的 global query plan，但 online 作法的限制錯失了這個機會。</li>
<li><a href="https://www.pdl.cmu.edu/PDL-FTP/Database/qpipe.pdf">SIGMOD'05 - QPipe</a>
<ul>
<li>早期做 work-sharing 的方式</li>
<li>簡單地偵測並 reuse 之前的 query result 或 intermediate result</li>
<li>通常都是看是否有拿過相同 range 的資料等等</li>
</ul>
</li>
<li><a href="https://faculty.ucmerced.edu/frusu/Papers/Contribution/2010-sigmod-datapath.pdf">SIGMOD'10 - DataPath</a>
<ul>
<li>嘗試將執行中的 query 與剛進來的 query 的 plan tree 合併，變成一棵 global plan tree，然後中間就有些部分可以 reuse。可以視為是將 common 的 sub-plan 組合起來。</li>
</ul>
</li>
<li><a href="https://dslab.epfl.ch/pubs/cjoin.pdf">VLDB'09 - CJOIN</a>
<ul>
<li>考慮將 operator reordering，確切來說會考慮優先將 selectivity 低的放前面，然而最佳來說並非是最好的做法。</li>
</ul>
</li>
<li><a href="https://dsf.berkeley.edu/papers/sigmod02-cacq.pdf">SIGMOD'02 - CACQ</a></li>
</ul>
</li>
<li>Offline sharing: 藉由在給定的 query batch 中嘗試所有可能的選項，以找到 cost 最低的選項。
<ul>
<li>這些做法的問題都在於問題的 solution space 太廣，導致只要 query 一多 complexity 就會變高。以致於 scalability 不佳。</li>
<li>Multi-query Optimization (MQO)
<ul>
<li>很多 work 都在解這個問題。</li>
<li>基本作法就是盡可能地遍歷所有 query 的可能 operator 組合，以找出最佳的 query plan。</li>
<li>每種做法的差異在於 bounding case 不同</li>
</ul>
</li>
<li><a href="http://www.vldb.org/pvldb/vol7/p429-giannikis.pdf">VLDB'14 - Shared-workload Optimizers (SWO)</a>
<ul>
<li>跟 MQO 的差異在於並非是以 batch of queries 做 input，而是還考慮了在一個 workload 中，每一種 query 出現的頻率。</li>
</ul>
</li>
</ul>
</li>
<li>應用的系統目前都是基於 SWO，所以會有 scalability issue
<ul>
<li>SharedDB</li>
<li>MQJoin</li>
</ul>
</li>
</ul>
<h3 id="adaptive-query-processing"><a class="header" href="#adaptive-query-processing">Adaptive Query Processing</a></h3>
<p>利用 query execution 中搜集到的資訊適度地動態調整 query plan。</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=jveohy_qhHU">Symmetric Hash-join</a>
<ul>
<li>一般的 hash join 是先對其中一個 join table 建立 (join key -&gt; record id) 的 hash table，然後再一一拉出另一邊 join table 的 record 來在 hash table 中尋找 match。</li>
<li>Symmetric Hash-join 則是對兩邊 join table 都建立一個 hash table，通常應用於 streamming query engine。因為不確定哪一邊的 table 資料會先過來，所以最好兩邊都建 hash table，然後讓一邊資料來的時候去查另一邊的 hash table。</li>
<li>缺點是需要花費大量記憶體建 hash table，因此一般的 DBMS 不會使用這種做法，通常只用於 stream process。</li>
</ul>
</li>
<li><a href="https://dsf.berkeley.edu/cs286/papers/eddies-sigmod2000.pdf">SIGMOD'00 - Eddies</a>: 藉由觀察 operator 的 input 與 output 來動態 reorder operator
<ul>
<li>Eddies 的概念是將 query plan 裡面先後順序可以替換的 operator 打散 (例如 hash join，任何的 join order 可能都不影響結果)，然後由 eddies 的 routing algorithm 來決定今天進來的一個 tuple 應該優先做哪一種 join。</li>
<li>Eddies 的 algorithm 會隨著狀況判斷每一個 tuple 該先進哪一個 operator (例如先做哪一個 join)。判斷的方式為記錄 operator 的 input 與 output 數量，如此一來可以知道先做哪一個 operator 可能比較有利。</li>
</ul>
</li>
<li><a href="https://dsf.berkeley.edu/papers/icde03-stems.pdf">ICDE'03 - State Modules (STeMs)</a>
<ul>
<li>如果我理解沒錯的話，就是一個 hash table</li>
<li>主要應用是在多重 SHJ，原本的 3-way 以上的 SHJ 在越上層的 join 就需要建越大的 hash table，因為越上層的 intermediate result 越大，而且 SHJ 要求 join 兩側都要建 hash table。然而 state modules 搭配 eddies 使用的話，就不需要建儲存 intermediate results 的 table。只需要為每一個 base table 建 hash table 就好。Eddies 會控制如何 join 這些 bash table。</li>
</ul>
</li>
</ul>
<h3 id="reinforcement-learning"><a class="header" href="#reinforcement-learning">Reinforcement Learning</a></h3>
<p>這篇使用 Q-Learning 應用在 reorder operator。</p>
<h3 id="learned-cardinality-estimation"><a class="header" href="#learned-cardinality-estimation">Learned Cardinality Estimation</a></h3>
<p>這篇利用之前 Learned Cardinality Estimation 相關的研究成果來預測 cardinality。</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<h3 id="assumtions"><a class="header" href="#assumtions">Assumtions</a></h3>
<ul>
<li>OLAP Workloads
<ul>
<li>Almost no update to the database</li>
<li>Queries intend to summary the statistics of the database</li>
</ul>
</li>
<li>只針對 select-project-join (SPJ) 的情況優化，其他則維持原本的處理方式
<ul>
<li>進一步假設這些 SPJ 的 query plan 都出現在整個 query plan 的最底層</li>
</ul>
</li>
</ul>
<h2 id="method"><a class="header" href="#method">Method</a></h2>
<h3 id="main-contribution"><a class="header" href="#main-contribution">Main Contribution</a></h3>
<ul>
<li>設計出 RL-based 的 tuple router (eddy)，來強化 online work sharing 的效果，以找到更好的 global query plan。</li>
</ul>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<ul>
<li>Episodes
<ul>
<li>每個 episode 取得一個 table 的 vector (vector size = 1024 tuples)，eddy 建立一個 global query plan，然後轉交給一個 executor 的 worker thread 做處理。</li>
</ul>
</li>
</ul>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<ul>
<li>Main DBMS
<ul>
<li>負責接收使用者 query 並轉成初步的 plan tree</li>
<li>得到 plan tree 之後會將 SPJ 的 sub-plan 送進 RouLette 處理，而這個 sub-plan 會用另一個 RouLette 的 place holder 替代。</li>
<li>DBMS 等待 RouLette 將 SPJ 的 tuples 送回，送回之後繼續執行 SPJ 以外的 query plan</li>
</ul>
</li>
<li>RouLette
<ul>
<li>Ingestion Module
<ul>
<li>負責從 DBMS 的 storage engine 索取 table 的資料，目標是用來 scan table</li>
<li>索取時以 vector 的形式取出，以使用 vectorized execution 的技巧優化</li>
<li>自己一個 thread</li>
<li>會為所有 ongoing 或者 incoming 的 query 所需的 table 的資料</li>
<li>會追蹤每一個 query scan 每一個 table 的起點，如此就可以知道針對某一個 query 來說是否已經 scan 完所有資料</li>
<li>每次輸出的 vector 上的每一個 tuple 會包含一個 bit set，紀錄該 tuple 要輸出給哪一些 query，如此一來後面的 component 就知道結果該輸出給哪些 query</li>
<li>Scan 的時候使用 round-robin 的方式公平地掃每一個需要的 table，以盡可能地服務到所有 query。</li>
</ul>
</li>
<li>STeMs
<ul>
<li>負責使用 in-memory index 暫存每一個 table 輸出的資料，以讓 Eddy Module 可以以任意順序存取需要的資料。而不是依照原本 plan tree 的邏輯存取。</li>
</ul>
</li>
<li>Eddy
<ul>
<li>負責在每一個 episode 產生一個 global query plan 處理所有 ongoing query 需要的資料。</li>
<li>會在 episode 之間動態調整 policy 以在之後的 episode 產生更好的 global plan</li>
<li>實作 selection push-down strategy。因此產生的 global plan 一定是 selection 在最底層，然後才是 join 與 projection。</li>
<li>Join 的 plan 會使用 multi-step optimization (MSO) 來產生，其使用的 policy 則是由 RL 在 episode 之間學習。</li>
<li>持續記錄每一個 operator 與 query 的 pair，operator 的 input 與 output，作為 state 供 RL 學習。</li>
</ul>
</li>
<li>Executor
<ul>
<li>有一個 worker thread pool，每一個 worker 負責處理一個 episode，一個 episode 包含輸入一個 table 的 vector 並執行 global query plan。</li>
<li>執行流程
<ol>
<li>收到 Ingestion 傳來的 input vector</li>
<li>進行 selection</li>
<li>插進對應的 STeM (hash table)</li>
<li>執行 Symetric Join</li>
<li>將結果的 tuple 回傳到 Main DBMS 給對應的 query plan</li>
</ol>
</li>
<li>執行時採用 vectorized execution</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="core-problems"><a class="header" href="#core-problems">Core Problems</a></h3>
<ul>
<li>How does Eddy generates a global query plan?</li>
<li>How does a worker thread efficently execute the query plan?</li>
</ul>
<h3 id="eddys-global-plan-geneartion-algorithm"><a class="header" href="#eddys-global-plan-geneartion-algorithm">Eddy's Global Plan Geneartion Algorithm</a></h3>
<ol>
<li>接收一個 input vector</li>
<li>找出與該 input vector 的 base relation 可以 join 的 relation，作為 candidates</li>
<li>選出最佳的 candidate relation 做 join</li>
<li>紀錄已經 join 的 relation 與符合這次 join 的 query set</li>
<li>加入新 join 的 table 的 selection (可能會有多種 selection 同時存在，因為要針對不同的 query 的 constraint 做處理)</li>
<li>繼續尋找 candidate 與 join</li>
<li>直到完成某一個 query join 的要件，紀錄該條 path 最後的 output 要傳遞至哪些 query</li>
<li>往回尋找分歧點 (導致某些 query 不符合的 join 點)，繼續尋找其他 candidate 並 join</li>
<li>直到所有 query 都有符合的 path 後結束</li>
</ol>
<p>選擇 candidate 時需要考慮的問題：</p>
<ul>
<li>盡可能讓越多 query share 越多 join 越好</li>
<li>Join Selectivity
<ul>
<li>任兩個 relation join 之後會有多少 record 是 match 的</li>
</ul>
</li>
<li>Join 後的資料量</li>
</ul>
<h3 id="candidate-selection-policy"><a class="header" href="#candidate-selection-policy">Candidate Selection Policy</a></h3>
<p>為了盡可能讓 Eddy 選擇最好的 candidate，它必須要使用以下幾項技術：</p>
<ul>
<li>Cost Estimation
<ul>
<li>概念是預測每一個 Operator 的 cost，這個 cost function 的 input 是 operator 的 input 與 output size</li>
<li>將 plan 的所有 operator 的 cost 全部加起來就是 plan 的 cost</li>
<li>Operator Cost 這篇定義為 computation cost，並且假定 linear to input size。Cost function 為：$K_a * n_{in} + \lambda_a * p(o) * n_{in}$，其中 $K_a、\lambda_a$ 為常數，$p(o)$ 是 operator 的 selectivity。
<ul>
<li>這篇論文對所有相同類型的 opeartor 使用相同的 $K_a、\lambda_a$ (join, selection)，數值是從過去的統計中計算出來的</li>
</ul>
</li>
</ul>
</li>
<li>Policy Goal: 找到一個 plan 的 total cost 是最低的
<ul>
<li>這個 goal 可以帶換成 RL 想要找到 total reward 是最高的</li>
<li>這件事情不容易做到的原因在於，我們是一步步把 candidate 接起來，所以在接前面的 operator 時，並不知道後面的 operator 會有哪些，而且會造成多少 cost。</li>
<li>另一種做法是可以 iterate 所有的 possible plan，但這樣在 online 做就太花時間。</li>
</ul>
</li>
<li>RL Modeling
<ul>
<li>State:
<ul>
<li>Virtual vector
<ul>
<li>代表這個 step 已經 join 的 relation 與符合條件的 query</li>
<li>如果有多條 path (對應不同的 query)，則 stack 起來變成長 vector</li>
</ul>
</li>
<li>Input size</li>
</ul>
</li>
<li>Action: 針對最上面那條 path 的 candidate 裡面選一個 operator</li>
<li>Reward: 選擇這個 candidate operator 所帶來的 cost (包含 join cost 與 selection cost)</li>
</ul>
</li>
</ul>
<h3 id="opeartor-implementation"><a class="header" href="#opeartor-implementation">Opeartor Implementation</a></h3>
<ul>
<li>Selection
<ul>
<li>每一個 tuple 都會有一個 query-set bitmap，代表這個 tuple 會用於那些 query。</li>
<li>每一個 selection operator 會對每一個 tuple 計算另一個 bitmap，然後把 tuple 本身的 bitmap 與這個 bitmap 取 AND。得到新的 bitmap。</li>
<li>在 predicate evaluation 的時候，會事先將所有 query 的 predicate 分成多個 range，其中每一個 range 會對應到一組 bitmap，並使用 binary search 的方式找 match 的 range，其 bitmap 就是該 tuple 的結果。</li>
</ul>
</li>
<li>Join
<ul>
<li>使用 SeTMs 來 join，join 完後再對兩者的 bitmap 取 AND 來決定要留下來些 record。</li>
</ul>
</li>
<li>Join Pruning</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Interesting problem and idea, but the in-memory assumption is not realistic.</p>
<h2 id="questions"><a class="header" href="#questions">Questions</a></h2>
<ul>
<li>Who are using work-sharing? Any practical examples?
<ul>
<li>就 paper 的理論來看好像大多還是用在 stream processing，但 batch processing 的情況也能夠使用。</li>
</ul>
</li>
<li>如果 where 條件不同也能夠 work sharing 嗎？有例子嗎？
<ul>
<li>可以，這篇論文的 Figure 8 就是在說明如何處理 where 不同的情況。</li>
</ul>
</li>
<li>Section 3 一開始提到 &quot;Ingestion pulls a vector from the host’s storage into RouLette.&quot;，為什麼是拉出 vectors？
<ul>
<li>為了做 vectorized execution</li>
</ul>
</li>
<li>如果我理解沒錯的話，RouLette 是否只有針對 Select-Project-Join 的 case 優化？
<ul>
<li>是，這篇論文只探討 Select-Project-Join 的優話</li>
</ul>
</li>
<li>如果我理解 STeMs 沒錯的話，就是一個有 index 的 in-memory data table。這是不是代表需要耗費大量記憶體暫存資料？但是 Data Warehouse 的資料通常很大，這些資料要如何暫存，記憶體空間肯定是不夠吧？
<ul>
<li>第三章最後有提到 STeMs 的實作採用 in-memory 的方式。因此記憶體大小會影響 RouLette 能處理的資料量。</li>
<li>另外也提到他們以 column store 的方式實作，所以拉取資料時只拉取有興趣的 column，以減少需要儲存的資料量。</li>
</ul>
</li>
<li>甚麼時候會移除 STeMs 的資料？
<ul>
<li>看起來整個 RouLette 的處理方式還是以 batch processing 為主，所以當這個 batch 處理完之後，就會刪除所有的 intermediate records (STeMs 的資料)。</li>
</ul>
</li>
<li>每個 episode 都要重建 global query plan，但又只用來 process 一個 vector of tuples，這真的會快嗎？
<ul>
<li>可能是因為它使用了 RL 的方式建立 query plan，所以基本上都是 O(1) 的 time complexity。另外 vector 大小也會影響重建 query plan 的次數。Paper 寫說他們 vector size 使用 1024，所以 episode 的數量並非到非常誇張的地步。</li>
</ul>
</li>
<li>為什麼可以將 query processing 切成 episode？這樣修改 query plan 不會出錯嗎？
<ul>
<li>不會，這邊是用到 symmetric hash join 的做法</li>
</ul>
</li>
<li>RL 的 cost estimation 為什麼重要？</li>
</ul>
<h2 id="slides-logics"><a class="header" href="#slides-logics">Slides Logics</a></h2>
<ul>
<li>Background
<ul>
<li>Query Processing
<ul>
<li>簡單複習一下流程：parsing query -&gt; optimize query plan -&gt; query execution</li>
</ul>
</li>
<li>Multi-query Processing in OLAP workloads
<ul>
<li>多個 query 同時處裡的時候，有機會可以共用一些資源</li>
<li>舉例：兩個 query 可能有 overlap 的 record set</li>
</ul>
</li>
<li>問題：然而當產生的 query plan 差距太大時，可能就難以利用到這種機會</li>
<li>這篇論文目標
<ul>
<li>Input: batch of queries</li>
<li>Goal: find a way to execute these queries fast</li>
<li>Assumption: main memory is large enough to fit the working set for the queries</li>
</ul>
</li>
</ul>
</li>
<li>Previous Work
<ul>
<li>Online work-sharing methods
<ul>
<li>QPipe: heuristics to reuse query result or intermediate results</li>
<li>DataPath: detect common sub-plans between multiple queries</li>
<li>CJoin: consider reordering some operators to find common sub-plans
<ul>
<li>TODO: need an example to show why it may not be optimal</li>
</ul>
</li>
</ul>
</li>
<li>Off-line work-sharing methods
<ul>
<li>MQO: iterate all possible query plan to find the optimal global plan for a set of queries.</li>
<li>SWO: similiar to MQO, but considers the frequency of query types.</li>
</ul>
</li>
</ul>
</li>
<li>RouLette
<ul>
<li>Key Idea
<ul>
<li>Global select-join query plan: 為所有 query 組成一個 global query plan，其中只考慮 select 跟 join 的優化。</li>
<li>Episodes: 將 query processing 切成多個 episodes，每個 episodes 處理一組 tuples，並產生獨立的 global plan。
<ul>
<li>這利用到了 Adaptive Query Processing (SIGMOD’00 - Eddies) 的概念，該論文提出應該一邊執行 query 一邊修正 query plan。但該論文只考慮 single-query。</li>
<li>好處：這樣可以逐步找到最好的 global query plan。</li>
</ul>
</li>
<li>Uses RL to improve global query plan</li>
</ul>
</li>
<li>System Overview (use examples to illustrate)
<ul>
<li>Workflow Graph</li>
<li>Main DBMS
<ul>
<li>Parse queries</li>
<li>Generate a query plan</li>
<li>Take out the select-join sub-plans to the RouLette engine</li>
<li>Wait for the RouLette engine outputs results for further processing</li>
</ul>
</li>
<li>RouLette Engine
<ul>
<li>Ingestion Module: scan each table and keep tracking the progress of scan for each queries
<ul>
<li>Output a vector of tuples for a table (vector size: 1024)</li>
</ul>
</li>
<li>Eddy Module: generate a global query plan
<ul>
<li>Idea: Selection -&gt; Join (selection-push-down)</li>
<li>Steps:
<ul>
<li>Put the selection operator for the tuples first 
<ul>
<li>Filter based on all where constraints</li>
<li>Uses a query-set bitmap</li>
</ul>
</li>
<li>Put insertion operator to a temp table (STeM)</li>
<li>Select a candidate join operator (based on RL)</li>
<li>Final Plan Tree</li>
</ul>
</li>
</ul>
</li>
<li>Executor Module: executes the query plan using a worker thread
<ul>
<li>Can run multiple episodes with multiple worker threads</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>RL Agent to select candidate operators
<ul>
<li>List state, action, reward</li>
</ul>
</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../dbms_with_ai/hilprecht2022zeroshot.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../rl_to_rank/summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../dbms_with_ai/hilprecht2022zeroshot.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../rl_to_rank/summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
